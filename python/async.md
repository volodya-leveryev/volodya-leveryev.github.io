---
layout: default
title: Асинхронное программирование
---
# Асинхронное программирование

Корутина — функция, которую можно приостанавливать и возобновлять. В Python определяется ключевым словом async def. При вызове корутина не выполняется сразу, а возвращает объект, который выполняется через await или внутри цикла событий (event loop).

Event loop (цикл событий) — механизм, который управляет выполнением корутин. Он регистрирует задачи, планирует их выполнение, переключается между ними, когда одна из задач ожидает ввода-вывода, и возобновляет, когда операция завершена. В Python управляется через `asyncio.get_event_loop()` или `asyncio.run()`.

Коллективная (кооперативная) многозадачность — модель, при которой задачи сами добровольно передают управление другим задачам. Планировщик не прерывает выполнение, пока задача явно не уступит управление (например, через await, yield или системный вызов ожидания).

Вытесняющая (принудительная) многозадачность — модель, при которой планировщик системы сам решает, когда прервать выполнение задачи и переключиться на другую. Контекст переключается по таймеру или внешнему событию, без участия самой задачи.

Асинхронное программирование в Python (через asyncio) реализует кооперативную (collective) многозадачность. Корутины сами уступают управление циклу событий с помощью await, когда выполняют операции ввода-вывода или явно вызывают другие асинхронные функции. Цикл событий (event loop) не прерывает корутину принудительно — если она не делает await, управление не возвращается, и остальные задачи «замерзают».

- `asyncio` = кооперативная многозадачность.
- `threading` / `multiprocessing` = вытесняющая многозадачность.

Преимущества асинхронного программирования
- Высокая производительность при I/O-задачах — позволяет не блокировать поток ожиданием сетевых или дисковых операций.
- Меньшее потребление ресурсов — не требует большого числа потоков или процессов.
- Хорошо масштабируется — подходит для серверов и сетевых приложений с тысячами одновременных подключений.

Недостатки
- Сложность отладки — стек вызовов и контекст переключения менее очевидны.
- Неэффективно для CPU-нагруженных задач — асинхронность не ускоряет вычисления.
- Совместимость — не все библиотеки поддерживают асинхронный ввод-вывод.
- Порог вхождения — требуется понимание корутин, цикла событий и конкурентных моделей.

- `asyncio` — выполняет корутины в рамках одного потока, не блокируя цикл событий.
- `threading` — выполняет потоки в одном процессе.
- `multiprocessing` — выполняет отдельные процессы, использует межпроцессное взаимодействие (IPC).

Мьютекс (mutex) — объект синхронизации, который разрешает доступ к ресурсу только одному потоку или процессу в момент времени. Захватывается (lock), выполняется критическая секция, затем освобождается (unlock).

Семафор (semaphore) — счетчик, ограничивающий число потоков или процессов, которым разрешён одновременный доступ к ресурсу. Например, Semaphore(3) позволит трем задачам одновременно выполнять код в защищённой области.

Барьер (barrier) — точка синхронизации, где несколько потоков или процессов ждут друг друга. Выполнение продолжается, когда все участники достигли барьера.

| Механизм    | threading               | multiprocessing                           | asyncio                                    |
| ----------- | ----------------------- | ----------------------------------------- | ------------------------------------------ |
| **Мьютекс** | `threading.Lock()`      | `multiprocessing.Lock()`                  | `asyncio.Lock()`                           |
| **Семафор** | `threading.Semaphore()` | `multiprocessing.Semaphore()`             | `asyncio.Semaphore()`                      |
| **Барьер**  | `threading.Barrier()`   | `multiprocessing.Barrier()` (ограниченно) | ❌ отсутствует (нужно реализовать вручную) |

```
import asyncio
import aiohttp

urls = [
    f"https://example.com/file{i}.txt" for i in range(1, 11)
]

async def download_file(session, url):
    filename = url.split("/")[-1]
    async with session.get(url) as response:
        response.raise_for_status()
        with open(filename, "wb") as f:
            f.write(await response.read())
    print(f"Downloaded {filename}")

async def main():
    async with aiohttp.ClientSession() as session:
        tasks = [download_file(session, url) for url in urls]
        await asyncio.gather(*tasks)

asyncio.run(main())
```

