# Синтаксис

Пример `for ... else`. Ветка `else` срабатывает если ни разу не встретился
`break`. Аналогично работает `while ... else`.

```python
for n in range(2, 20):
    for x in range(2, n):
        if n % x == 0:
            break
    else:
        print(n, "— простое число")

# Аналогичный код, но без else:
found = False
for n in range(2, 20):
    for x in range(2, n):
        if n % x == 0:
            found = True
            break
if not found:
    print(n, "— простое число")
```

###############################################################################

Управляющие символы в строках начинаются на `\`.
[Таблица в документации Python](https://docs.python.org/3/reference/lexical_analysis.html#escape-sequences).

```
import time

for i in range(101):
    print(f"\rВыполнено: {i}%", end="")
    time.sleep(0.05)
print()  # Перевод строки после завершения
```

###############################################################################

```
# Передача произвольного количества аргументов в функцию
def print_args_kwargs(*args, **kwargs):
    print("Позиционные аргументы:", type(args))
    print("Позиционные аргументы:", args)
    print("Именованные аргументы:", type(kwargs))
    print("Именованные аргументы:", kwargs)

print_args_kwargs(1, 2, 3, имя="Алиса", возраст=20)
```

###############################################################################

Строгое указание типа аргумента: позиционный или именованный.
Аргументы слева от / должны передаваться только по позиции.
Аргументы справа от * должны передаваться только по имени.

```
def show_args(a, /, b, *, c):
    print(f"a = {a}")
    print(f"b = {b}")
    print(f"c = {c}")

show_args(1, 2, 3)          # Ошибка! c должен быть только именованным
show_args(1, 2, c=3)        # Корректно
show_args(1, b=2, c=3)      # Корректно
show_args(a=1, b=2, c=3)    # Ошибка! a должен быть только позиционными
```

###############################################################################

```
# Объявление декоратора
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Перед вызовом функции")
        result = func(*args, **kwargs)
        print("После вызова функции")
        return result
    return wrapper

# Использование декоратора
@my_decorator
def say_hello(name):
    print(f"Привет, {name}!")

say_hello("Алиса")
```

###############################################################################

```
# Объявление - это функция, которая создает декоратор
def custom_decorator(msg_before, msg_after):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(msg_before)
            result = func(*args, **kwargs)
            print(msg_after)
            return result
        return wrapper
    return decorator

# Использование - создается декоратор
@custom_decorator("Начало работы", "Завершено")
def process():
    print("Выполняется основная функция")

process()
```

###############################################################################

Функция возвращает ссылку на локальный контекст.
Поэтому локальный контекст не удаляется после завершения функции и локальный
контекст становится замыканием.

```
def make_counter(start=0):
    count = start
    def counter():
        nonlocal count
        print(count)
        count += 1
    return counter

c = make_counter(5)
c()  # 5
c()  # 6
c()  # 7
```

###############################################################################

```
from abc import ABC, abstractmethod

# Абстрактный базовый класс
# Нельзя создавать объекты такого класса
class Animal(ABC):
    @abstractmethod
    def make_sound(self):
        pass

# В дочернем класс обязательно должны быть реализованы абстрактные методы
class Dog(Animal):
    def make_sound(self):
        print("Гав!")

# В дочернем класс обязательно должны быть реализованы абстрактные методы
class Cat(Animal):
    def make_sound(self):
        print("Мяу!")

# animal = Animal()  # Ошибка! Нельзя создать экземпляр абстрактного класса
dog = Dog()
dog.make_sound()  # Гав!
```

###############################################################################

Cайт о проектировании ООП и паттернах проектирования:
https://refactoring.guru/
https://github.com/RefactoringGuru

Объявление о новых функциях в Python 3.14:
https://docs.python.org/3.14/whatsnew/3.14.html

###############################################################################

Напишите функцию-декоратор, которая определяет сколько времени работает оборачиваемая функция.
Для определения момента времени используйте функцию time() из пакета time.
Результат работы должен быть напечатан на экран после завершения работы обертываемой функции.

Сохраните у себя до следующей пары.

###############################################################################

```
def counter():
    if not hasattr(counter, 'count'):
        counter.count = 0
    counter.count += 1
    print(counter.count)

counter()  # 1
counter()  # 2
counter()  # 3
```

###############################################################################

```
# Без моржового оператора
text = input("Введите строку: ")
while text != "stop":
    print(f"Длина: {len(text)}")
    text = input("Введите строку: ")

# С моржовым оператором
while (text := input("Введите строку: ")) != "stop":
    print(f"Длина: {len(text)}")
```

###############################################################################

```
a = {"a": 1, "b": 2}
b = {"b": 3, "c": 4}
print(a | b)
print({**a, **b})
a.update(b)
print(a)
```

###############################################################################

```
def handle_command(command):
    match command:
        case ("move", x, y):
            return f"Перемещение в точку ({x}, {y})"
        case ("say", message):
            return f"Сообщение: {message}"
        case ("exit",):
            return "Выход"
        case _:
            return "Неизвестная команда"

print(handle_command(("move", 10, 20)))  # Перемещение в точку (10, 20)
print(handle_command(("say", "Привет"))) # Сообщение: Привет
print(handle_command(("exit",)))         # Выход
print(handle_command(("jump",)))         # Неизвестная команда
```

